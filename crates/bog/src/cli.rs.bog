#[file(
  owner = "cli-agent",
  subsystem = "cli",
  updated = "2026-02-24",
  status = green
)]

#[description {
  CLI command definitions and dispatch. Implements init, validate, status,
  check, stub, and skim commands. Thin layer: delegates to validator,
  health, and stub modules.
}]

#[health(
  test_coverage = yellow,
  staleness = green,
  complexity = green,
  contract_compliance = green
)]

#[fn(run) {
  status = green,
  deps = [cmd_init, cmd_validate, cmd_status, cmd_check],
  contract = {
    in = [(cli, Cli)],
    out = "Result<(), Box<dyn Error>>"
  },
  description = "Dispatches CLI command to handler"
}]

#[fn(cmd_init) {
  status = green,
  description = "Scaffolds bog.toml, repo.bog, and example sidecar"
}]

#[fn(cmd_validate) {
  status = green,
  deps = [validator::validate_project],
  description = "Runs full project validation and prints results"
}]

#[fn(cmd_status) {
  status = green,
  deps = [health::compute_health, health::format_health_report],
  description = "Computes and prints health report"
}]

#[fn(cmd_check) {
  status = green,
  deps = [validator::validate_project],
  description = "Runs ownership consistency checks"
}]

#[fn(cmd_skim) {
  status = green,
  deps = [health::compute_health, parser::parse_bog],
  description = "Shows skimsystem health, principles, and observations"
}]

#[fn(cmd_stub) {
  status = green,
  deps = [stub::find_missing_annotations, stub::apply_stubs],
  description = "Generates stubs for unannotated functions and writes them to .bog files"
}]

#[fn(cmd_stub_list) {
  status = green,
  deps = [stub::list_stubs],
  description = "Lists all stub annotations across the project"
}]

#[skim(tracing) {
  status = red,
  notes = "No tracing instrumentation. CLI commands need INFO logs at step boundaries (validate started, status computed, etc.), WARN on non-fatal issues, ERROR before panics. Each fn needs at least one TRACE."
}]

#[skim(annotation-quality) {
  status = yellow,
  notes = "test_coverage is yellow; CLI commands have no unit tests"
}]




// [integration:code-quality:clippy]
#[skim(code-quality) {
  status = red,
  notes = "clippy: 12 warning(s)"
}]

#[change_requests {
  #[request(
    id = "code-quality-clippy-8e90894fc0a34399",
    from = "code-standards-agent",
    target = fn(run),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::missing_errors_doc (line 69): docs for function returning `Result` missing `# Errors` section"
  )]
  #[request(
    id = "code-quality-clippy-f69991cab4653c07",
    from = "code-standards-agent",
    target = fn(cmd_validate),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 202): this function's return value is unnecessary"
  )]
  #[request(
    id = "code-quality-clippy-e5a14223348af51e",
    from = "code-standards-agent",
    target = fn(cmd_status),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 232): this function's return value is unnecessary"
  )]
  #[request(
    id = "code-quality-clippy-0651e9bf40a368e4",
    from = "code-standards-agent",
    target = fn(cmd_check),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 250): this function's return value is unnecessary"
  )]
  #[request(
    id = "code-quality-clippy-9067e93bb8c24396",
    from = "code-standards-agent",
    target = fn(cmd_skim),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 291): this function's return value is unnecessary"
  )]
  #[request(
    id = "code-quality-clippy-cf55375d90a91db6",
    from = "code-standards-agent",
    target = fn(cmd_skim),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::map_unwrap_or (line 410): called `map(<f>).unwrap_or(false)` on an `Option` value"
  )]
  #[request(
    id = "code-quality-clippy-ce6c621ed9879cfd",
    from = "code-standards-agent",
    target = fn(cmd_skim),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 414): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-23afb75633d12e8c",
    from = "code-standards-agent",
    target = fn(cmd_skim),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 417): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-e144d2fb06ca9c0d",
    from = "code-standards-agent",
    target = fn(cmd_skim_run),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 468): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-36db83f658d0dd04",
    from = "code-standards-agent",
    target = fn(cmd_skim_run),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::single_match_else (line 483): you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`"
  )]
  #[request(
    id = "code-quality-clippy-69ca4316bb593bdc",
    from = "code-standards-agent",
    target = fn(cmd_stub),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 554): this function's return value is unnecessary"
  )]
  #[request(
    id = "code-quality-clippy-801cea8513a8032e",
    from = "code-standards-agent",
    target = fn(cmd_stub_list),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 599): this function's return value is unnecessary"
  )]
}]

#[fn(cmd_skim_run) {
  status = green,
  deps = [integration::run_integration, integration::write_integration_results, integration::print_report],
  description = "Runs a skimsystem integration action end-to-end: execute tool, write results to .bog files, print report"
}]
