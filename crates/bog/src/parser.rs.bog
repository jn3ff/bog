#[file(
  owner = "core-agent",
  subsystem = "core",
  updated = "2026-02-24",
  status = green
)]

#[description {
  Pest-based parser for .bog files. Transforms PEG parse tree into AST types.
  The grammar lives in parser.pest. This module maps pest Pairs to ast::Annotation
  variants, handling all annotation types: repo, file, description, health, fn,
  subsystem, policies, and change_requests.
}]

#[health(
  test_coverage = green,
  staleness = green,
  complexity = yellow,
  contract_compliance = green
)]

#[fn(parse_bog) {
  status = green,
  contract = {
    in = [(input, str)],
    out = "Result<BogFile, ParseError>",
    invariants = ["returns all annotations in source order"]
  },
  description = "Public entry point: parse .bog text into a BogFile AST"
}]

#[fn(parse_annotation) {
  status = green,
  deps = [parse_repo, parse_file, parse_description, parse_health, parse_fn, parse_subsystem, parse_policies, parse_change_requests],
  description = "Dispatches a single annotation to its type-specific parser"
}]

#[fn(extract_kv_map) {
  status = green,
  description = "Collects key-value pairs from a pest Pairs iterator into a HashMap"
}]

#[fn(get_kv_list_from_parens) {
  status = green,
  description = "Extracts kv_list from a parens rule"
}]

#[fn(get_ident_from_parens) {
  status = green,
  description = "Extracts a single identifier from a parens rule"
}]

#[fn(get_body_kv_map) {
  status = green,
  description = "Extracts kv_list from a body rule"
}]

#[fn(get_body_text) {
  status = green,
  description = "Extracts raw text from a body rule, used for description blocks"
}]

#[fn(require_string) {
  status = green,
  description = "Extracts a required string field from a kv map, errors if missing"
}]

#[fn(require_status) {
  status = green,
  description = "Extracts a required status field from a kv map, errors if missing"
}]

#[fn(opt_string) {
  status = green,
  description = "Extracts an optional string field from a kv map"
}]

#[fn(extract_string_list) {
  status = green,
  description = "Extracts a list of strings from a kv map value"
}]

#[fn(unquote) {
  status = green,
  description = "Strips surrounding quotes and unescapes a string literal"
}]

#[fn(parse_value) {
  status = green,
  description = "Converts a pest value Pair into an ast::Value"
}]

#[fn(parse_list_item_value) {
  status = green,
  description = "Converts a pest list_item Pair into an ast::Value"
}]

#[fn(parse_repo) {
  status = green,
  description = "Parses #[repo(...)] into RepoAnnotation"
}]

#[fn(parse_file) {
  status = green,
  description = "Parses #[file(...)] into FileAnnotation"
}]

#[fn(parse_description) {
  status = green,
  description = "Parses #[description { ... }] into Description text"
}]

#[fn(parse_health) {
  status = green,
  description = "Parses #[health(...)] into HealthAnnotation"
}]

#[fn(parse_fn) {
  status = green,
  description = "Parses #[fn(name) { ... }] into FnAnnotation with optional contract"
}]

#[fn(parse_subsystem) {
  status = green,
  description = "Parses #[subsystem(name) { ... }] into SubsystemDecl"
}]

#[fn(parse_policies) {
  status = green,
  description = "Parses #[policies { ... }] into PoliciesAnnotation"
}]

#[fn(parse_change_requests) {
  status = green,
  description = "Parses #[change_requests { ... }] containing nested #[request(...)] entries"
}]

#[fn(test_parse_file_annotation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[file(...)] annotations into FileAnnotation"
}]

#[fn(test_parse_description) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[description { ... }] blocks into text"
}]

#[fn(test_parse_health) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[health(...)] annotations with status dimensions"
}]

#[fn(test_parse_fn_annotation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[fn(name) { ... }] annotations with deps and contracts"
}]

#[fn(test_parse_repo) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[repo(...)] annotations into RepoAnnotation"
}]

#[fn(test_parse_subsystem) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[subsystem(name) { ... }] declarations"
}]

#[fn(test_parse_policies) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[policies { ... }] annotations"
}]

#[fn(test_parse_change_requests) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[change_requests { ... }] with nested #[request(...)] entries"
}]

#[fn(test_parse_with_comments) {
  status = green,
  deps = [parse_bog],
  description = "Verifies that comments are correctly ignored during parsing"
}]

#[fn(test_parse_repo_bog) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of a complete repo.bog file with subsystems and policies"
}]

#[fn(test_parse_full_file_bog) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of a complete file-level .bog sidecar with all annotation types"
}]




#[skim(tracing) {
  status = red,
  notes = "No tracing instrumentation. parse_bog needs DEBUG with input length and annotation count. parse_annotation needs TRACE per annotation dispatched. Helper fns need TRACE."
}]

// [integration:code-quality:clippy]
#[skim(code-quality) {
  status = red,
  notes = "clippy: 21 warning(s)"
}]

#[change_requests {
  #[request(
    id = "code-quality-clippy-e1069ffaf3ee892d",
    from = "code-standards-agent",
    target = file,
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::wildcard_imports (line 7): usage of wildcard import"
  )]
  #[request(
    id = "code-quality-clippy-dd8d53398390349a",
    from = "code-standards-agent",
    target = fn(parse_bog),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::missing_panics_doc (line 28): docs for function which may panic missing `# Panics` section"
  )]
  #[request(
    id = "code-quality-clippy-3cbcdb056d2479be",
    from = "code-standards-agent",
    target = fn(parse_bog),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::missing_errors_doc (line 28): docs for function returning `Result` missing `# Errors` section"
  )]
  #[request(
    id = "code-quality-clippy-d4e70295adebef3d",
    from = "code-standards-agent",
    target = fn(get_kv_list_from_parens),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 78): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-69ae3e25f6bdc37f",
    from = "code-standards-agent",
    target = fn(get_ident_from_parens),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 93): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-fa842aeec4ca0732",
    from = "code-standards-agent",
    target = fn(get_body_kv_map),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 108): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-e6a18f864db41754",
    from = "code-standards-agent",
    target = fn(get_body_kv_map),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 109): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-4dd38fd4f2687223",
    from = "code-standards-agent",
    target = fn(get_body_kv_map),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 110): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-d63882acb9d33bfd",
    from = "code-standards-agent",
    target = fn(get_body_text),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 125): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-85129b0db4992fb6",
    from = "code-standards-agent",
    target = fn(get_body_text),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 126): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-07eb133e48b9bfe0",
    from = "code-standards-agent",
    target = fn(parse_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::match_same_arms (line 258): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-25da9bd3edb70183",
    from = "code-standards-agent",
    target = fn(parse_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::redundant_closure_for_method_calls (line 225): redundant closure"
  )]
  #[request(
    id = "code-quality-clippy-57a5cf71f9317a65",
    from = "code-standards-agent",
    target = fn(parse_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::match_same_arms (line 247): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-b55f120acb3e0b7f",
    from = "code-standards-agent",
    target = fn(parse_list_item_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::match_same_arms (line 305): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-9b8ca2dae7463570",
    from = "code-standards-agent",
    target = fn(parse_list_item_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::redundant_closure_for_method_calls (line 287): redundant closure"
  )]
  #[request(
    id = "code-quality-clippy-e2e39a5cba27d45c",
    from = "code-standards-agent",
    target = fn(parse_list_item_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::match_same_arms (line 299): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-f290c3b9f22f0da3",
    from = "code-standards-agent",
    target = fn(parse_description),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::unnecessary_wraps (line 330): this function's return value is unnecessarily wrapped by `Result`"
  )]
  #[request(
    id = "code-quality-clippy-86a323b53b7605bf",
    from = "code-standards-agent",
    target = fn(parse_fn),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 360): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-24f9bd6a9c80dd21",
    from = "code-standards-agent",
    target = fn(parse_change_requests),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 539): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-f51029d8a84ef47b",
    from = "code-standards-agent",
    target = fn(parse_change_requests),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 540): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-74e5cef8b45378dd",
    from = "code-standards-agent",
    target = fn(parse_change_requests),
    type = lint_warning,
    status = pending,
    created = "2026-02-25",
    description = "clippy::collapsible_if (line 541): this `if` statement can be collapsed"
  )]
}]

#[fn(parse_skimsystem) {
  status = green,
  deps = [get_body_kv_map, get_ident_from_parens, extract_string_list, require_status, require_string, opt_string],
  description = "Parses #[skimsystem(name) { ... }] into SkimsystemDecl with targets, principles, and integrations"
}]

#[fn(parse_skim) {
  status = green,
  deps = [get_body_kv_map, get_ident_from_parens, require_status, opt_string],
  description = "Parses #[skim(name) { ... }] observation into SkimObservation with optional fn target"
}]

#[fn(test_parse_skimsystem) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[skimsystem(name) { ... }] with named targets and principles"
}]

#[fn(test_parse_skimsystem_targets_all) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of skimsystem with targets = all"
}]

#[fn(test_parse_skimsystem_with_integrations) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of skimsystem with integrations block"
}]

#[fn(test_parse_skim_observation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[skim(name) { ... }] observation"
}]

#[fn(test_parse_skim_with_fn_target) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of skim observation with target = fn(name)"
}]
