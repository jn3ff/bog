#[file(
  owner = "core-agent",
  subsystem = "core",
  updated = "2026-02-24",
  status = green
)]

#[description {
  Pest-based parser for .bog files. Transforms PEG parse tree into AST types.
  The grammar lives in parser.pest. This module maps pest Pairs to ast::Annotation
  variants, handling all annotation types: repo, file, description, health, fn,
  subsystem, policies, and change_requests.
}]

#[health(
  test_coverage = green,
  staleness = green,
  complexity = yellow,
  contract_compliance = green
)]

#[fn(parse_bog) {
  status = green,
  contract = {
    in = [(input, str)],
    out = "Result<BogFile, ParseError>",
    invariants = ["returns all annotations in source order"]
  },
  description = "Public entry point: parse .bog text into a BogFile AST"
}]

#[fn(parse_annotation) {
  status = green,
  deps = [parse_repo, parse_file, parse_description, parse_health, parse_fn, parse_subsystem, parse_policies, parse_change_requests],
  description = "Dispatches a single annotation to its type-specific parser"
}]

#[fn(extract_kv_map) {
  status = green,
  description = "Collects key-value pairs from a pest Pairs iterator into a HashMap"
}]

#[fn(get_kv_list_from_parens) {
  status = green,
  description = "Extracts kv_list from a parens rule"
}]

#[fn(get_ident_from_parens) {
  status = green,
  description = "Extracts a single identifier from a parens rule"
}]

#[fn(get_body_kv_map) {
  status = green,
  description = "Extracts kv_list from a body rule"
}]

#[fn(get_body_text) {
  status = green,
  description = "Extracts raw text from a body rule, used for description blocks"
}]

#[fn(require_string) {
  status = green,
  description = "Extracts a required string field from a kv map, errors if missing"
}]

#[fn(require_status) {
  status = green,
  description = "Extracts a required status field from a kv map, errors if missing"
}]

#[fn(opt_string) {
  status = green,
  description = "Extracts an optional string field from a kv map"
}]

#[fn(extract_string_list) {
  status = green,
  description = "Extracts a list of strings from a kv map value"
}]

#[fn(unquote) {
  status = green,
  description = "Strips surrounding quotes and unescapes a string literal"
}]

#[fn(parse_value) {
  status = green,
  description = "Converts a pest value Pair into an ast::Value"
}]

#[fn(parse_list_item_value) {
  status = green,
  description = "Converts a pest list_item Pair into an ast::Value"
}]

#[fn(parse_repo) {
  status = green,
  description = "Parses #[repo(...)] into RepoAnnotation"
}]

#[fn(parse_file) {
  status = green,
  description = "Parses #[file(...)] into FileAnnotation"
}]

#[fn(parse_description) {
  status = green,
  description = "Parses #[description { ... }] into Description text"
}]

#[fn(parse_health) {
  status = green,
  description = "Parses #[health(...)] into HealthAnnotation"
}]

#[fn(parse_fn) {
  status = green,
  description = "Parses #[fn(name) { ... }] into FnAnnotation with optional contract"
}]

#[fn(parse_subsystem) {
  status = green,
  description = "Parses #[subsystem(name) { ... }] into SubsystemDecl"
}]

#[fn(parse_policies) {
  status = green,
  description = "Parses #[policies { ... }] into PoliciesAnnotation"
}]

#[fn(parse_change_requests) {
  status = green,
  description = "Parses #[change_requests { ... }] containing nested #[request(...)] entries"
}]

#[fn(test_parse_file_annotation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[file(...)] annotations into FileAnnotation"
}]

#[fn(test_parse_description) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[description { ... }] blocks into text"
}]

#[fn(test_parse_health) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[health(...)] annotations with status dimensions"
}]

#[fn(test_parse_fn_annotation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[fn(name) { ... }] annotations with deps and contracts"
}]

#[fn(test_parse_repo) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[repo(...)] annotations into RepoAnnotation"
}]

#[fn(test_parse_subsystem) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[subsystem(name) { ... }] declarations"
}]

#[fn(test_parse_policies) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[policies { ... }] annotations"
}]

#[fn(test_parse_change_requests) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[change_requests { ... }] with nested #[request(...)] entries"
}]

#[fn(test_parse_with_comments) {
  status = green,
  deps = [parse_bog],
  description = "Verifies that comments are correctly ignored during parsing"
}]

#[fn(test_parse_repo_bog) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of a complete repo.bog file with subsystems and policies"
}]

#[fn(test_parse_full_file_bog) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of a complete file-level .bog sidecar with all annotation types"
}]


// [integration:code-quality:clippy]
#[skim(code-quality) {
  status = red,
  notes = "clippy: 21 warning(s)"
}]

#[change_requests {
  #[request(
    id = "code-quality-clippy-d6e0a8f34846c459",
    from = "quality-agent",
    target = file,
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::wildcard_imports (line 7): usage of wildcard import"
  )]
  #[request(
    id = "code-quality-clippy-7ef584fc18abf745",
    from = "quality-agent",
    target = fn(parse_bog),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::missing_panics_doc (line 28): docs for function which may panic missing `# Panics` section"
  )]
  #[request(
    id = "code-quality-clippy-5cb13b9422a9b4a4",
    from = "quality-agent",
    target = fn(parse_bog),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::missing_errors_doc (line 28): docs for function returning `Result` missing `# Errors` section"
  )]
  #[request(
    id = "code-quality-clippy-af89766d776d269e",
    from = "quality-agent",
    target = fn(get_kv_list_from_parens),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 78): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-47ba71ae6fa79414",
    from = "quality-agent",
    target = fn(get_ident_from_parens),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 93): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-c60e32ebe4f9b55c",
    from = "quality-agent",
    target = fn(get_body_kv_map),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 108): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-0156a2de0c17959e",
    from = "quality-agent",
    target = fn(get_body_kv_map),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 109): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-3108813197557451",
    from = "quality-agent",
    target = fn(get_body_kv_map),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 110): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-08e9b69af0c9d18e",
    from = "quality-agent",
    target = fn(get_body_text),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 125): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-d2700081270a0a43",
    from = "quality-agent",
    target = fn(get_body_text),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 126): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-a4067d242302986e",
    from = "quality-agent",
    target = fn(parse_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::match_same_arms (line 258): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-5804a1025a47b478",
    from = "quality-agent",
    target = fn(parse_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::redundant_closure_for_method_calls (line 225): redundant closure"
  )]
  #[request(
    id = "code-quality-clippy-34491d2bdf4a67db",
    from = "quality-agent",
    target = fn(parse_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::match_same_arms (line 247): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-279fd8fb44980cf9",
    from = "quality-agent",
    target = fn(parse_list_item_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::match_same_arms (line 305): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-b7766d79f3f1868a",
    from = "quality-agent",
    target = fn(parse_list_item_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::redundant_closure_for_method_calls (line 287): redundant closure"
  )]
  #[request(
    id = "code-quality-clippy-8d764da891683bb7",
    from = "quality-agent",
    target = fn(parse_list_item_value),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::match_same_arms (line 299): these match arms have identical bodies"
  )]
  #[request(
    id = "code-quality-clippy-e2fa70f25e575d5f",
    from = "quality-agent",
    target = fn(parse_description),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::unnecessary_wraps (line 330): this function's return value is unnecessarily wrapped by `Result`"
  )]
  #[request(
    id = "code-quality-clippy-4373878d87f4ab8a",
    from = "quality-agent",
    target = fn(parse_fn),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 360): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-5846cd7ff1fd0bfe",
    from = "quality-agent",
    target = fn(parse_change_requests),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 539): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-c48349e28fab6e58",
    from = "quality-agent",
    target = fn(parse_change_requests),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 540): this `if` statement can be collapsed"
  )]
  #[request(
    id = "code-quality-clippy-f7e460912ea777e6",
    from = "quality-agent",
    target = fn(parse_change_requests),
    type = lint_warning,
    status = pending,
    created = "2026-02-24",
    description = "clippy::collapsible_if (line 541): this `if` statement can be collapsed"
  )]
}]
