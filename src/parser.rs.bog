#[file(
  owner = "core-agent",
  subsystem = "core",
  updated = "2026-02-24",
  status = green
)]

#[description {
  Pest-based parser for .bog files. Transforms PEG parse tree into AST types.
  The grammar lives in parser.pest. This module maps pest Pairs to ast::Annotation
  variants, handling all annotation types: repo, file, description, health, fn,
  subsystem, policies, and change_requests.
}]

#[health(
  test_coverage = green,
  staleness = green,
  complexity = yellow,
  contract_compliance = green
)]

#[fn(parse_bog) {
  status = green,
  contract = {
    in = [(input, str)],
    out = "Result<BogFile, ParseError>",
    invariants = ["returns all annotations in source order"]
  },
  description = "Public entry point: parse .bog text into a BogFile AST"
}]

#[fn(parse_annotation) {
  status = green,
  deps = [parse_repo, parse_file, parse_description, parse_health, parse_fn, parse_subsystem, parse_policies, parse_change_requests],
  description = "Dispatches a single annotation to its type-specific parser"
}]

#[fn(extract_kv_map) {
  status = green,
  description = "Collects key-value pairs from a pest Pairs iterator into a HashMap"
}]

#[fn(get_kv_list_from_parens) {
  status = green,
  description = "Extracts kv_list from a parens rule"
}]

#[fn(get_ident_from_parens) {
  status = green,
  description = "Extracts a single identifier from a parens rule"
}]

#[fn(get_body_kv_map) {
  status = green,
  description = "Extracts kv_list from a body rule"
}]

#[fn(get_body_text) {
  status = green,
  description = "Extracts raw text from a body rule, used for description blocks"
}]

#[fn(require_string) {
  status = green,
  description = "Extracts a required string field from a kv map, errors if missing"
}]

#[fn(require_status) {
  status = green,
  description = "Extracts a required status field from a kv map, errors if missing"
}]

#[fn(opt_string) {
  status = green,
  description = "Extracts an optional string field from a kv map"
}]

#[fn(extract_string_list) {
  status = green,
  description = "Extracts a list of strings from a kv map value"
}]

#[fn(unquote) {
  status = green,
  description = "Strips surrounding quotes and unescapes a string literal"
}]

#[fn(parse_value) {
  status = green,
  description = "Converts a pest value Pair into an ast::Value"
}]

#[fn(parse_list_item_value) {
  status = green,
  description = "Converts a pest list_item Pair into an ast::Value"
}]

#[fn(parse_repo) {
  status = green,
  description = "Parses #[repo(...)] into RepoAnnotation"
}]

#[fn(parse_file) {
  status = green,
  description = "Parses #[file(...)] into FileAnnotation"
}]

#[fn(parse_description) {
  status = green,
  description = "Parses #[description { ... }] into Description text"
}]

#[fn(parse_health) {
  status = green,
  description = "Parses #[health(...)] into HealthAnnotation"
}]

#[fn(parse_fn) {
  status = green,
  description = "Parses #[fn(name) { ... }] into FnAnnotation with optional contract"
}]

#[fn(parse_subsystem) {
  status = green,
  description = "Parses #[subsystem(name) { ... }] into SubsystemDecl"
}]

#[fn(parse_policies) {
  status = green,
  description = "Parses #[policies { ... }] into PoliciesAnnotation"
}]

#[fn(parse_change_requests) {
  status = green,
  description = "Parses #[change_requests { ... }] containing nested #[request(...)] entries"
}]

#[fn(test_parse_file_annotation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[file(...)] annotations into FileAnnotation"
}]

#[fn(test_parse_description) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[description { ... }] blocks into text"
}]

#[fn(test_parse_health) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[health(...)] annotations with status dimensions"
}]

#[fn(test_parse_fn_annotation) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[fn(name) { ... }] annotations with deps and contracts"
}]

#[fn(test_parse_repo) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[repo(...)] annotations into RepoAnnotation"
}]

#[fn(test_parse_subsystem) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[subsystem(name) { ... }] declarations"
}]

#[fn(test_parse_policies) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[policies { ... }] annotations"
}]

#[fn(test_parse_change_requests) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of #[change_requests { ... }] with nested #[request(...)] entries"
}]

#[fn(test_parse_with_comments) {
  status = green,
  deps = [parse_bog],
  description = "Verifies that comments are correctly ignored during parsing"
}]

#[fn(test_parse_repo_bog) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of a complete repo.bog file with subsystems and policies"
}]

#[fn(test_parse_full_file_bog) {
  status = green,
  deps = [parse_bog],
  description = "Verifies parsing of a complete file-level .bog sidecar with all annotation types"
}]
